process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';

var async = require('async');
var request = require('request');
var _ = require('underscore');
var moment = require('moment');
var allActivities = [];
var startDate;
var p;
var url;

module.exports = function(startD, config, bf, callback) {
  allActivities = [];
  startDate = startD;
  p = config;

  makeUrl(bf, function() {
    makeApiCall(function(err, d) {
      if (err) {
        callback(err);
        return;
      } else {
        reject(_.flatten(allActivities), function(err, da) {
          returnedFields(da, function(err, dat) {
            callback(null, dat);
          });
        });
      }
    });
  });
  /*return function(callback) {

      async.doWhilst(function(callback) {
          makeApiCall(function(data) {
              if(data == 'err') {
                  callback('nothing');
                  return;
              }
              callback(null, activity);
          });
      }, function() {
          if (activity == 'empty') {
              p.mapData.paginationStart = 1;
              return false;
          } else {
              p.mapData.paginationStart += p.mapData.paginationInterval;
              allActivities.push(activity);
              activity = [];
              return true;
          };
      }, function(error) {
          p.mapData.paginationStart = 1;
          if(error) {
              callback('error');
          } else {
              for(var i = 1; i < allActivities.length; i++) {
                  Array.prototype.push.apply(allActivities[0],allActivities[i]);
              }

              var forComp = m.rejectByQueue(m.flatten(allActivities), 'Outbound');
              if (dailyCount == 0) {
                  dailyCount = forComp.length;
                  console.log('daily count changed1: ' + dailyCount);
                  callback(null, forComp);
              } else if(dailyCount == forComp.length) {
                  callback('no changes');
              } else {
                  var nDailyCount = forComp.length;
                  m.extractChanges(forComp, dailyCount, function(err, d) {
                      dailyCount = nDailyCount;
                      console.log('daily count changed2: ' + dailyCount);
                      callback(null, d);
                  });
              };
          };
      });
  };*/
};

function makeUrl(bf, callback) {
  var diff = moment().diff(moment(startDate), 'days');
  console.log('DIFFERENCe IS: ' + diff);
  if (diff == 0 || bf) {
    console.log('URL SET TO TODAY');
    p.mapData.dateRange = 'today';
    console.log(p.mapData.dateRange);
    callback();
  } else {
    var start = moment().subtract(diff, 'days');
    p.mapData.dateRange = start.format('YYYY-MM-DD') + ',' +
        moment().format('YYYY-MM-DD');
    console.log('URL SET TO DATE RANGE');
    console.log(p.mapData.dateRange);
    callback();
  }
}

function makeApiCall(callback) {
  var status;

  async.doWhilst(
      function(cb) {
        httpRequest(function(err, d) {
          if (d == 'ERROR' || d == 'FAILED') {
            status = d;
          } else {
            allActivities.push(d);
          }
          cb(null, d);
        });
      },
      function() {
        if (status == 'ERROR' || status == 'FAILED') {
          return false;
        } else {
          return true;
        }
      },
      function() {
        if (status == 'ERROR') {
          callback(status);
          return;
        } else {
          callback(null, allActivities);
        }
      }
  );
};

function httpRequest(callback) {
  var activity = [];
  console.log(
      p.protocol + p.host + p.mapData.uri + p.mapData.dateRange + '&n=' +
      String(p.mapData.paginationStart));
  request(
      {
        method: p.method,
        uri: p.protocol + p.host + p.mapData.uri + p.mapData.dateRange + '&n=' +
            String(p.mapData.paginationStart),
        //proxy: "http://127.0.0.1:8888", // Note the fully-qualified path to Fiddler proxy. No "https" is required, even for https connections to outside.
        headers: {
          'Authorization': 'Basic ' + new Buffer(
              p.phoneSystemUsername + ':' + p.phoneSystemGetToken).toString(
              'base64'),
        },
      },
      function(err, response, body) {
        if (err || response.statusCode != 200) {
          console.log('Error in HTTP call or Status code not 200');
          p.mapData.paginationStart = 1;
          callback(null, 'ERROR');
        } else {
          var activity = JSON.parse(body)['activities']['activity'] || 'FAILED';
          if (activity == 'FAILED') {
            p.mapData.paginationStart = 1;
            callback(null, 'FAILED');
          } else {
            p.mapData.paginationStart += p.mapData.paginationInterval;
            callback(null, activity);
          }
        }
      }
  );
};

function reject(data, callback) {
  callback(null, _.reject(_.reject(_.reject(data, function(r) {
    return r['media-type'] != 'Phone';
  }), function(q) {
    return q['trans-transfer-from'] == 'yes';
  }), function(que) {
    return que['queue-name'] == 'Outbound';
  }));
};

function returnedFields(data, callback) {

  for (var i = 0; i < data.length; i++) {
    var json = {};
    for (var j = 0; j < p.returnedFields.length; j++) {
      json[p.returnedFields[j]] = data[i][p.returnedFields[j]];
    }
    data[i] = json;
  }
  ;
  callback(null, data);
};
